### Summary
how to solve a problem

|step|describe|
|---|---|
|Concrete examples|Manually solve concrete instances of the problem and then build a general solution.|
|Graph modeling|Describe the problem using a graph and solve it using an existing algorithm.|
|Case analysis|Split the input/execution into a number of cases and solve each case in isolation.| 
|Iterative refinement|Most problems can be solved using a brute-force approach. Find such a solution and improve upon it.|
|Reduction|Use a well-known solution to some other problem as a subroutine.|

### data structure
#### primitive
[see detail](./basic/primitive.md)
#### array
[see detail](./basic/array.md)
#### string
[see detail](./basic/string.md)
#### linked list
[see detail](./basic/linkedlist.md)
#### stack and queue
[see detail](./basic/stack_queue.md)
#### heap

#### hash table

#### binary search tree

###  algorithm pattern

|technique|key points|
|---|---|
|Sorting|Uncover some structure by sorting the input.| 
|Recursion|If the structure of the input is defined in a recursive manner, design a recursive algorithm that follows the input definition.|
|Divide-and-conquer|Divide the problem into two or more smaller independent sub-problems and solve the original problem using solutions to the sub-problems.| 
|Dynamic programming|Compute solutions for smaller instances of a given problem and use these solutions to construct a solution to the problem. Cache for performance.| 
|Greedy algorithms|Compute a solution in stages, making choices that are locally optimum at step; these choices are never undone.| 
|Invariants|Identify an invariant and use it to rule out potential solutions that are suboptimal/dominated by other solutions.|
